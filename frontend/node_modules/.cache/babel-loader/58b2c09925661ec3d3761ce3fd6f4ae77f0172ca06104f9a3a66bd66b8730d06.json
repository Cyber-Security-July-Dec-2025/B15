{"ast":null,"code":"import * as openpgp from 'openpgp';\n\n// AES encryption for private key\nexport const encryptPrivateKeyAES = async (privateKeyArmored, password) => {\n  const encrypted = await openpgp.encrypt({\n    message: await openpgp.createMessage({\n      text: privateKeyArmored\n    }),\n    passwords: [password],\n    format: 'armored'\n  });\n  return encrypted; // This should be a string\n};\nexport const decryptPrivateKeyAES = async (encryptedPrivateKey, password) => {\n  const message = await openpgp.readMessage({\n    armoredMessage: encryptedPrivateKey\n  });\n  const {\n    data: decrypted\n  } = await openpgp.decrypt({\n    message,\n    passwords: [password],\n    format: 'armored'\n  });\n  return decrypted; // This should be the original armored private key string\n};\nexport const generateKeyPair = async (username, password) => {\n  try {\n    const {\n      privateKey,\n      publicKey\n    } = await openpgp.generateKey({\n      type: 'rsa',\n      rsaBits: 2048,\n      userIDs: [{\n        name: username,\n        email: `${username}@securechat.local`\n      }],\n      passphrase: password\n    });\n    return {\n      privateKey,\n      publicKey\n    };\n  } catch (error) {\n    throw new Error('Failed to generate key pair: ' + error.message);\n  }\n};\nexport const getFingerprint = async publicKeyArmored => {\n  try {\n    const publicKey = await openpgp.readKey({\n      armoredKey: publicKeyArmored\n    });\n    return publicKey.getFingerprint().toUpperCase().match(/.{1,4}/g).join(' ');\n  } catch (error) {\n    throw new Error('Failed to get fingerprint: ' + error.message);\n  }\n};\nexport const encryptMessage = async (message, recipientPublicKey) => {\n  try {\n    const publicKey = await openpgp.readKey({\n      armoredKey: recipientPublicKey\n    });\n    const encrypted = await openpgp.encrypt({\n      message: await openpgp.createMessage({\n        text: message\n      }),\n      encryptionKeys: publicKey\n    });\n    return encrypted;\n  } catch (error) {\n    throw new Error('Failed to encrypt message: ' + error.message);\n  }\n};\nexport const decryptMessage = async (encryptedMessage, privateKeyArmored, passphrase) => {\n  try {\n    const message = await openpgp.readMessage({\n      armoredMessage: encryptedMessage\n    });\n    const privateKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readPrivateKey({\n        armoredKey: privateKeyArmored\n      }),\n      passphrase\n    });\n    const {\n      data: decrypted\n    } = await openpgp.decrypt({\n      message,\n      decryptionKeys: privateKey\n    });\n    return decrypted;\n  } catch (error) {\n    throw new Error('Failed to decrypt message: ' + error.message);\n  }\n};\nexport const hybridEncryptMessage = async (message, recipientPublicKeyArmored) => {\n  // Generate random AES key (256-bit)\n  const aesKeyBytes = new Uint8Array(32);\n  window.crypto.getRandomValues(aesKeyBytes);\n  const aesKeyHex = Array.from(aesKeyBytes).map(b => b.toString(16).padStart(2, '0')).join('');\n\n  // Encrypt message with AES key\n  const encryptedMessage = await openpgp.encrypt({\n    message: await openpgp.createMessage({\n      text: message\n    }),\n    passwords: [aesKeyHex],\n    format: 'armored'\n  });\n\n  // Encrypt AES key with recipient's public key\n  const recipientPublicKey = await openpgp.readKey({\n    armoredKey: recipientPublicKeyArmored\n  });\n  const encryptedAESKey = await openpgp.encrypt({\n    message: await openpgp.createMessage({\n      text: aesKeyHex\n    }),\n    encryptionKeys: recipientPublicKey,\n    format: 'armored'\n  });\n  return {\n    encryptedMessage,\n    encryptedAESKey\n  };\n};\nexport const hybridDecryptMessage = async (encryptedMessage, encryptedAESKey, privateKeyArmored, passphrase) => {\n  // Decrypt AES key with private key\n  const privateKey = await openpgp.decryptKey({\n    privateKey: await openpgp.readPrivateKey({\n      armoredKey: privateKeyArmored\n    }),\n    passphrase\n  });\n  const aesKeyMessage = await openpgp.readMessage({\n    armoredMessage: encryptedAESKey\n  });\n  const {\n    data: aesKeyHex\n  } = await openpgp.decrypt({\n    message: aesKeyMessage,\n    decryptionKeys: privateKey,\n    format: 'armored'\n  });\n\n  // Decrypt message with AES key\n  const message = await openpgp.readMessage({\n    armoredMessage: encryptedMessage\n  });\n  const {\n    data: decrypted\n  } = await openpgp.decrypt({\n    message,\n    passwords: [aesKeyHex],\n    format: 'armored'\n  });\n  return decrypted;\n};","map":{"version":3,"names":["openpgp","encryptPrivateKeyAES","privateKeyArmored","password","encrypted","encrypt","message","createMessage","text","passwords","format","decryptPrivateKeyAES","encryptedPrivateKey","readMessage","armoredMessage","data","decrypted","decrypt","generateKeyPair","username","privateKey","publicKey","generateKey","type","rsaBits","userIDs","name","email","passphrase","error","Error","getFingerprint","publicKeyArmored","readKey","armoredKey","toUpperCase","match","join","encryptMessage","recipientPublicKey","encryptionKeys","decryptMessage","encryptedMessage","decryptKey","readPrivateKey","decryptionKeys","hybridEncryptMessage","recipientPublicKeyArmored","aesKeyBytes","Uint8Array","window","crypto","getRandomValues","aesKeyHex","Array","from","map","b","toString","padStart","encryptedAESKey","hybridDecryptMessage","aesKeyMessage"],"sources":["/home/rounak-dagar/securechat/frontend/src/services/crypto.js"],"sourcesContent":["import * as openpgp from 'openpgp';\n\n// AES encryption for private key\nexport const encryptPrivateKeyAES = async (privateKeyArmored, password) => {\n  const encrypted = await openpgp.encrypt({\n    message: await openpgp.createMessage({ text: privateKeyArmored }),\n    passwords: [password],\n    format: 'armored'\n  });\n  return encrypted; // This should be a string\n};\n\nexport const decryptPrivateKeyAES = async (encryptedPrivateKey, password) => {\n  const message = await openpgp.readMessage({ armoredMessage: encryptedPrivateKey });\n  const { data: decrypted } = await openpgp.decrypt({\n    message,\n    passwords: [password],\n    format: 'armored'\n  });\n  return decrypted; // This should be the original armored private key string\n};\n\nexport const generateKeyPair = async (username, password) => {\n  try {\n    const { privateKey, publicKey } = await openpgp.generateKey({\n      type: 'rsa',\n      rsaBits: 2048,\n      userIDs: [{ name: username, email: `${username}@securechat.local` }],\n      passphrase: password\n    });\n\n    return { privateKey, publicKey };\n  } catch (error) {\n    throw new Error('Failed to generate key pair: ' + error.message);\n  }\n};\n\nexport const getFingerprint = async (publicKeyArmored) => {\n  try {\n    const publicKey = await openpgp.readKey({ armoredKey: publicKeyArmored });\n    return publicKey.getFingerprint().toUpperCase().match(/.{1,4}/g).join(' ');\n  } catch (error) {\n    throw new Error('Failed to get fingerprint: ' + error.message);\n  }\n};\n\nexport const encryptMessage = async (message, recipientPublicKey) => {\n  try {\n    const publicKey = await openpgp.readKey({ armoredKey: recipientPublicKey });\n    \n    const encrypted = await openpgp.encrypt({\n      message: await openpgp.createMessage({ text: message }),\n      encryptionKeys: publicKey\n    });\n\n    return encrypted;\n  } catch (error) {\n    throw new Error('Failed to encrypt message: ' + error.message);\n  }\n};\n\nexport const decryptMessage = async (encryptedMessage, privateKeyArmored, passphrase) => {\n  try {\n    const message = await openpgp.readMessage({ armoredMessage: encryptedMessage });\n    const privateKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readPrivateKey({ armoredKey: privateKeyArmored }),\n      passphrase\n    });\n\n    const { data: decrypted } = await openpgp.decrypt({\n      message,\n      decryptionKeys: privateKey\n    });\n\n    return decrypted;\n  } catch (error) {\n    throw new Error('Failed to decrypt message: ' + error.message);\n  }\n};\n\nexport const hybridEncryptMessage = async (message, recipientPublicKeyArmored) => {\n  // Generate random AES key (256-bit)\n  const aesKeyBytes = new Uint8Array(32);\n  window.crypto.getRandomValues(aesKeyBytes);\n  const aesKeyHex = Array.from(aesKeyBytes).map(b => b.toString(16).padStart(2, '0')).join('');\n\n  // Encrypt message with AES key\n  const encryptedMessage = await openpgp.encrypt({\n    message: await openpgp.createMessage({ text: message }),\n    passwords: [aesKeyHex],\n    format: 'armored'\n  });\n\n  // Encrypt AES key with recipient's public key\n  const recipientPublicKey = await openpgp.readKey({ armoredKey: recipientPublicKeyArmored });\n  const encryptedAESKey = await openpgp.encrypt({\n    message: await openpgp.createMessage({ text: aesKeyHex }),\n    encryptionKeys: recipientPublicKey,\n    format: 'armored'\n  });\n\n  return {\n    encryptedMessage,\n    encryptedAESKey\n  };\n};\n\nexport const hybridDecryptMessage = async (encryptedMessage, encryptedAESKey, privateKeyArmored, passphrase) => {\n  // Decrypt AES key with private key\n  const privateKey = await openpgp.decryptKey({\n    privateKey: await openpgp.readPrivateKey({ armoredKey: privateKeyArmored }),\n    passphrase\n  });\n  const aesKeyMessage = await openpgp.readMessage({ armoredMessage: encryptedAESKey });\n  const { data: aesKeyHex } = await openpgp.decrypt({\n    message: aesKeyMessage,\n    decryptionKeys: privateKey,\n    format: 'armored'\n  });\n\n  // Decrypt message with AES key\n  const message = await openpgp.readMessage({ armoredMessage: encryptedMessage });\n  const { data: decrypted } = await openpgp.decrypt({\n    message,\n    passwords: [aesKeyHex],\n    format: 'armored'\n  });\n\n  return decrypted;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}