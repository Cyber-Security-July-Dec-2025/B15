{"ast":null,"code":"import * as openpgp from 'openpgp';\n\n// AES encryption for private key\nexport const encryptPrivateKeyAES = async (privateKeyArmored, password) => {\n  const encrypted = await openpgp.encrypt({\n    message: await openpgp.createMessage({\n      text: privateKeyArmored\n    }),\n    passwords: [password],\n    format: 'armored'\n  });\n  return encrypted; // This should be a string\n};\nexport const decryptPrivateKeyAES = async (encryptedPrivateKey, password) => {\n  const message = await openpgp.readMessage({\n    armoredMessage: encryptedPrivateKey\n  });\n  const {\n    data: decrypted\n  } = await openpgp.decrypt({\n    message,\n    passwords: [password],\n    format: 'armored'\n  });\n  return decrypted; // This should be the original armored private key string\n};\n\n// Key generation (no passphrase)\nexport const generateKeyPair = async username => {\n  const {\n    privateKey,\n    publicKey\n  } = await openpgp.generateKey({\n    type: 'rsa',\n    rsaBits: 2048,\n    userIDs: [{\n      name: username,\n      email: `${username}@securechat.local`\n    }]\n  });\n  return {\n    privateKey,\n    publicKey\n  };\n};\nexport const getFingerprint = async publicKeyArmored => {\n  try {\n    const publicKey = await openpgp.readKey({\n      armoredKey: publicKeyArmored\n    });\n    return publicKey.getFingerprint().toUpperCase().match(/.{1,4}/g).join(' ');\n  } catch (error) {\n    throw new Error('Failed to get fingerprint: ' + error.message);\n  }\n};\nexport const encryptMessage = async (message, recipientPublicKey) => {\n  try {\n    const publicKey = await openpgp.readKey({\n      armoredKey: recipientPublicKey\n    });\n    const encrypted = await openpgp.encrypt({\n      message: await openpgp.createMessage({\n        text: message\n      }),\n      encryptionKeys: publicKey\n    });\n    return encrypted;\n  } catch (error) {\n    throw new Error('Failed to encrypt message: ' + error.message);\n  }\n};\nexport const decryptMessage = async (encryptedMessage, privateKeyArmored, passphrase) => {\n  try {\n    const message = await openpgp.readMessage({\n      armoredMessage: encryptedMessage\n    });\n    const privateKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readPrivateKey({\n        armoredKey: privateKeyArmored\n      }),\n      passphrase\n    });\n    const {\n      data: decrypted\n    } = await openpgp.decrypt({\n      message,\n      decryptionKeys: privateKey\n    });\n    return decrypted;\n  } catch (error) {\n    throw new Error('Failed to decrypt message: ' + error.message);\n  }\n};\nexport const hybridEncryptMessage = async (message, recipientPublicKeyArmored) => {\n  // Generate random AES key (256-bit)\n  const aesKeyBytes = new Uint8Array(32);\n  window.crypto.getRandomValues(aesKeyBytes);\n  const aesKeyHex = Array.from(aesKeyBytes).map(b => b.toString(16).padStart(2, '0')).join('');\n\n  // Encrypt message with AES key\n  const encryptedMessage = await openpgp.encrypt({\n    message: await openpgp.createMessage({\n      text: message\n    }),\n    passwords: [aesKeyHex],\n    format: 'armored'\n  });\n\n  // Encrypt AES key with recipient's public key\n  const recipientPublicKey = await openpgp.readKey({\n    armoredKey: recipientPublicKeyArmored\n  });\n  const encryptedAESKey = await openpgp.encrypt({\n    message: await openpgp.createMessage({\n      text: aesKeyHex\n    }),\n    encryptionKeys: recipientPublicKey,\n    format: 'armored'\n  });\n  return {\n    encryptedMessage,\n    encryptedAESKey\n  };\n};\n\n// Hybrid decryption (no passphrase)\nexport const hybridDecryptMessage = async (encryptedMessage, encryptedAESKey, privateKeyArmored) => {\n  // Decrypt AES key with private key\n  const privateKey = await openpgp.readPrivateKey({\n    armoredKey: privateKeyArmored\n  });\n  const aesKeyMessage = await openpgp.readMessage({\n    armoredMessage: encryptedAESKey\n  });\n  const {\n    data: aesKeyHex\n  } = await openpgp.decrypt({\n    message: aesKeyMessage,\n    decryptionKeys: privateKey,\n    format: 'armored'\n  });\n\n  // Decrypt message with AES key\n  const message = await openpgp.readMessage({\n    armoredMessage: encryptedMessage\n  });\n  const {\n    data: decrypted\n  } = await openpgp.decrypt({\n    message,\n    passwords: [aesKeyHex],\n    format: 'armored'\n  });\n  return decrypted;\n};","map":{"version":3,"names":["openpgp","encryptPrivateKeyAES","privateKeyArmored","password","encrypted","encrypt","message","createMessage","text","passwords","format","decryptPrivateKeyAES","encryptedPrivateKey","readMessage","armoredMessage","data","decrypted","decrypt","generateKeyPair","username","privateKey","publicKey","generateKey","type","rsaBits","userIDs","name","email","getFingerprint","publicKeyArmored","readKey","armoredKey","toUpperCase","match","join","error","Error","encryptMessage","recipientPublicKey","encryptionKeys","decryptMessage","encryptedMessage","passphrase","decryptKey","readPrivateKey","decryptionKeys","hybridEncryptMessage","recipientPublicKeyArmored","aesKeyBytes","Uint8Array","window","crypto","getRandomValues","aesKeyHex","Array","from","map","b","toString","padStart","encryptedAESKey","hybridDecryptMessage","aesKeyMessage"],"sources":["/home/rounak-dagar/securechat/frontend/src/services/crypto.js"],"sourcesContent":["import * as openpgp from 'openpgp';\n\n// AES encryption for private key\nexport const encryptPrivateKeyAES = async (privateKeyArmored, password) => {\n  const encrypted = await openpgp.encrypt({\n    message: await openpgp.createMessage({ text: privateKeyArmored }),\n    passwords: [password],\n    format: 'armored'\n  });\n  return encrypted; // This should be a string\n};\n\nexport const decryptPrivateKeyAES = async (encryptedPrivateKey, password) => {\n  const message = await openpgp.readMessage({ armoredMessage: encryptedPrivateKey });\n  const { data: decrypted } = await openpgp.decrypt({\n    message,\n    passwords: [password],\n    format: 'armored'\n  });\n  return decrypted; // This should be the original armored private key string\n};\n\n// Key generation (no passphrase)\nexport const generateKeyPair = async (username) => {\n  const { privateKey, publicKey } = await openpgp.generateKey({\n    type: 'rsa',\n    rsaBits: 2048,\n    userIDs: [{ name: username, email: `${username}@securechat.local` }]\n  });\n  return { privateKey, publicKey };\n};\n\nexport const getFingerprint = async (publicKeyArmored) => {\n  try {\n    const publicKey = await openpgp.readKey({ armoredKey: publicKeyArmored });\n    return publicKey.getFingerprint().toUpperCase().match(/.{1,4}/g).join(' ');\n  } catch (error) {\n    throw new Error('Failed to get fingerprint: ' + error.message);\n  }\n};\n\nexport const encryptMessage = async (message, recipientPublicKey) => {\n  try {\n    const publicKey = await openpgp.readKey({ armoredKey: recipientPublicKey });\n    \n    const encrypted = await openpgp.encrypt({\n      message: await openpgp.createMessage({ text: message }),\n      encryptionKeys: publicKey\n    });\n\n    return encrypted;\n  } catch (error) {\n    throw new Error('Failed to encrypt message: ' + error.message);\n  }\n};\n\nexport const decryptMessage = async (encryptedMessage, privateKeyArmored, passphrase) => {\n  try {\n    const message = await openpgp.readMessage({ armoredMessage: encryptedMessage });\n    const privateKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readPrivateKey({ armoredKey: privateKeyArmored }),\n      passphrase\n    });\n\n    const { data: decrypted } = await openpgp.decrypt({\n      message,\n      decryptionKeys: privateKey\n    });\n\n    return decrypted;\n  } catch (error) {\n    throw new Error('Failed to decrypt message: ' + error.message);\n  }\n};\n\nexport const hybridEncryptMessage = async (message, recipientPublicKeyArmored) => {\n  // Generate random AES key (256-bit)\n  const aesKeyBytes = new Uint8Array(32);\n  window.crypto.getRandomValues(aesKeyBytes);\n  const aesKeyHex = Array.from(aesKeyBytes).map(b => b.toString(16).padStart(2, '0')).join('');\n\n  // Encrypt message with AES key\n  const encryptedMessage = await openpgp.encrypt({\n    message: await openpgp.createMessage({ text: message }),\n    passwords: [aesKeyHex],\n    format: 'armored'\n  });\n\n  // Encrypt AES key with recipient's public key\n  const recipientPublicKey = await openpgp.readKey({ armoredKey: recipientPublicKeyArmored });\n  const encryptedAESKey = await openpgp.encrypt({\n    message: await openpgp.createMessage({ text: aesKeyHex }),\n    encryptionKeys: recipientPublicKey,\n    format: 'armored'\n  });\n\n  return {\n    encryptedMessage,\n    encryptedAESKey\n  };\n};\n\n// Hybrid decryption (no passphrase)\nexport const hybridDecryptMessage = async (encryptedMessage, encryptedAESKey, privateKeyArmored) => {\n  // Decrypt AES key with private key\n  const privateKey = await openpgp.readPrivateKey({ armoredKey: privateKeyArmored });\n  const aesKeyMessage = await openpgp.readMessage({ armoredMessage: encryptedAESKey });\n  const { data: aesKeyHex } = await openpgp.decrypt({\n    message: aesKeyMessage,\n    decryptionKeys: privateKey,\n    format: 'armored'\n  });\n\n  // Decrypt message with AES key\n  const message = await openpgp.readMessage({ armoredMessage: encryptedMessage });\n  const { data: decrypted } = await openpgp.decrypt({\n    message,\n    passwords: [aesKeyHex],\n    format: 'armored'\n  });\n\n  return decrypted;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}